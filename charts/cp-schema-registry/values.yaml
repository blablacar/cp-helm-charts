# Default values for cp-schema-registry.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

## ------------------------------------------------------
## Schema Registry
## ------------------------------------------------------

## Number of Scheme Registry Pod
replicaCount: 1

## Image Info
## ref: https://hub.docker.com/r/confluentinc/cp-schema-registry/
image: eu.gcr.io/bbc-registry/cp-schema-registry
imageTag: &version 7.3.1

## Specify a imagePullPolicy
## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
imagePullPolicy: IfNotPresent

## Specify an array of imagePullSecrets.
## Secrets must be manually created in the namespace.
## ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
imagePullSecrets:

## Schema Registry Settings Overrides
## Configuration Options can be found here: https://docs.confluent.io/current/schema-registry/docs/config.html
configurationOverrides:
  kafkastore.security.protocol: "SSL"
  kafkastore.ssl.keystore.location: "/data/client_crt/user.p12"
  kafkastore.ssl.keystore.type: "PKCS12"
  kafkastore.ssl.truststore.location: "/data/server_crt/ca.p12"
  kafkastore.ssl.truststore.type: "PKCS12"

## Additional env variables
customEnv:
  SCHEMA_REGISTRY_KAFKASTORE_GROUP_ID: "schema-registry-consumer-group-id"

## The port on which the Schema Registry will be available and serving requests
servicePort: 8081

## Schema registry JVM Heap Option
heapOptions: "-Xms512M -Xmx512M"

## You can list load balanced service endpoint, or list of all brokers (which is hard in K8s).  e.g.:
## bootstrapServers: "PLAINTEXT://dozing-prawn-kafka-headless:9092"
## Charts uses Kafka Coordinator Master Election: https://docs.confluent.io/current/schema-registry/docs/design.html#kafka-coordinator-master-election
kafka:
  bootstrapServers: ""

clientCrtSecret: "schema-registry-service-account"
serverCrtSecret: "" # depending on the kafka cluster to connect to, the pattern is {cluster-name}-cluster-ca-c

volumeMounts: {}
#  - name: server-secret-volume
#    mountPath: /data/server_crt

env: {}
#  - name: SCHEMA_REGISTRY_KAFKASTORE_SSL_TRUSTSTORE_PASSWORD
#    valueFrom:
#      secretKeyRef:
#        name: my-cluster-name-cluster-ca-cert
#        key: ca.password

## List of volumeMounts for connect server container
## ref: https://kubernetes.io/docs/concepts/storage/volumes/
volumes: {}
#  - name: server-secret-volume
#    secret:
#      secretName: my-cluster-name-cluster-ca-cert
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

datadog:
  enabled: true
  annotations:
    ad.datadoghq.com/cp-schema-registry-server.check_names: '["openmetrics"]'
    ad.datadoghq.com/cp-schema-registry-server.init_configs: '[{}]'
    ad.datadoghq.com/cp-schema-registry-server.logs: '[{"source":"schema-registry","service":"{{ .Release.Name }}"}]'
    ad.datadoghq.com/cp-schema-registry-server.instances: |
      [{
      "prometheus_url": "http://%%host%%:5556/metrics",
      "namespace": "schema_registry",
      "metrics": [
        "cp_kafka_schema_registry_jetty_metrics_connections_active",
        "cp_kafka_schema_registry_jetty_metrics_connections_opened_rate",
        "cp_kafka_schema_registry_jetty_metrics_connections_closed_rate",
        "cp_kafka_schema_registry_jersey_metrics_request_error_rate",
        "cp_kafka_schema_registry_master_slave_role",
        "cp_kafka_schema_registry_jersey_metrics_request_byte_rate",
        "cp_kafka_schema_registry_jersey_metrics_request_latency_avg",
        "cp_kafka_schema_registry_jersey_metrics_request_size_avg",
        "jvm*"
      ],
      "type_overrides": {
        "*": "gauge",
        ".+_total": "counter"
      }
      }]
  labels:
    team: "team_dbre"

## Custom pod annotations
podAnnotations:
  cluster-autoscaler.kubernetes.io/safe-to-evict: "true"  # Allow the autoscaler to downscale the cluster.

## Node labels for pod assignment
## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
nodeSelector:
  dedicated: "datastores"

## Taints to tolerate on node assignment:
## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
tolerations:
  - key: dedicated
    operator: Equal
    value: "datastores"
    effect: NoSchedule

podDisruptionBudget:
  maxUnavailable: 1

## Privilege and access control settings for a Pod or Container
## https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
securityContext:
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  runAsNonRoot: true

## Monitoring
## Schema Registry JMX Settings
## ref: https://docs.confluent.io/current/schema-registry/docs/monitoring.html
jmx:
  port: 5555

## Prometheus Exporter Configuration
## ref: https://prometheus.io/docs/instrumenting/exporters/
prometheus:
  ## JMX Exporter Configuration
  ## ref: https://github.com/prometheus/jmx_exporter
  jmx:
    enabled: true
    image: solsson/kafka-prometheus-jmx-exporter@sha256
    imageTag: 6f82e2b0464f50da8104acd7363fb9b995001ddff77d248379f8788e78946143
    imagePullPolicy: IfNotPresent
    port: 5556
    resources: {}
  serviceMonitor: # defines monitoring for a service when using prometheus operator
    enabled: true
    jobLabel: app

ui:
  annotations: {}
  labels:
    sidecar.istio.io/inject: "false"
  replicaCount: 1
  resources:
    requests:
      cpu: 10m
      memory: 30Mi
    limits:
      memory: 100Mi
